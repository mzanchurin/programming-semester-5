# Добрый день, группа 312!
<style type="text/css">
div.sourceCode {
  font-size: 1.2em;
}
section.slide > pre {
  font-size: 0.8em;
}

.reveal pre {
  width: 99%;
}
.reveal pre code {
  font-size: 1.2em;
}
.yellow-box {
  background-color: #afa;
}
.sparse-matrix img {
  height: 450px;
}
.twocolumn {
  -moz-column-count: 2;
  -webkit-column-count: 2;
}
</style>

## Курс «Практикум на ЭВМ» (по численным методам)

### Осенний семестр. Методы решения линейных систем нахождений собственных значений
Я — **Андрей Александрович Зензинов**


email: [andrey.zenzinov@gmail.com](mailto:andrey.zenzinov@gmail.com)

Материалы к занятиям: https://zenderro.github.io/programming-semester-5/

# Дистанционное обучение

В этом году, в отличие от предыдущих, занятия будут проходить полностью дистанционно.

Этот материал может содержать отсылки к работе в дисплейных классах, которые в настоящее время недоступны.

# Как получить зачёт

Зачёт состоит из двух частей: теория, практика (решение задач).

Зачёт по теории, письменный, общий (весь курс пишет одновременно).

Для допуска к зачёту нужно сдать решения 3 задач (не считая подготовительных задач).

Каждая последующая задача выдаётся после сдачи предыдущей.

Схема проведения зачётов:

0. До начала зачётной недели — досрочный теоретический зачёт (для тех, кто сдал все 3 задачи заранее, примерно до середины ноября).
1. В начале зачётной недели — теоретический зачёт (для тех, кто успел сдать 3 задачи на занятиях).
2. Два практических зачёта по 1.5 часа. Те, кто не успел сдать задачи за эти два зачёт отправляются на пересдачу.
3. Во второй половине зачётной недели — второй теоретический зачёт (для тех, кто успел сдать 3 задачи за время практических зачётов).
4. Пересдача — после каникул, в феврале. Задачи принимает комиссия из нескольких преподавателей кафедры.

В какой именно форме будет проходить сдача теории будет известно позже.

# Литература
Основной курс со списком вопросов к зачёту:

- К. Ю. Богачёв. **Практикум на ЭВМ. Методы решения линейных систем и нахождения собственных значений.**
  («Методы приближения функций» — в следующем семестре)

Материалы по практике:

- *Язык программирования C*: Б. Керниган, Д. Ритчи. Язык программирования C, [А.В.Столяров. Программирование: введение в профессию](http://stolyarov.info/books/programming_intro), С. Прата. «Язык программирования C. Лекции и упражнения», [Викиучебник «Язык Си в примерах»](https://ru.wikibooks.org/wiki/Язык_Си_в_примерах);
- *Отладчик GDB:* [Руководство по использованию отладчика GDB](http://rus-linux.net/nlib.php?name=/MyLDP/algol/gdb/otladka-s-gdb.html), Н.Н. Иванов «Программирование в Linux. Самоучитель» (глава 28)
- *Командная оболочка Linux:* Д. Тейнсли. Linux и Unix: программирование в Shell. Руководство разработчика.

- К. Ю. Богачёв. Основы параллельного программирования (для третьей задачи и для следующего семестра).

# Как готовить задачи

Сдача задач будет организована на базе GitHub Classroom.

Есть несколько вариантов по созданию рабочего окружения для решения задач:

- Установить Linux (проще всего Ubuntu/Kubuntu), установить туда gcc, gdb
- Для Macbook — можно работать в Mac OS X, почти всё будет близко к Linux
- Установить Linux в виртуальной машине (компьютер должен иметь >= 8 Gb памяти, можно попробовать Xubuntu с 4)
- Для Windows (до 10) — установить [Cygwin](http://cygwin.com)
- Для Windows 10 — установить [Windows Subsystem for Linux](https://docs.microsoft.com/ru-ru/windows/wsl/install-win10)

# Настройки компилятора

В дисплейных классах установлены специальные настройки компилятора — более строго, чем обычно, контролируется соответствие программ стандарту, кроме того, более широкий класс ошибок приводит к аварийному завершению программы. Как получить близкое поведение на своей машине:

- Добавить к командной строке флаги:
```bash
gcc -std=c99 -Wall -Werror -Wshadow -pedantic-errors \
-Wpointer-arith -Waggregate-return \
-Wstrict-prototypes -Wmissing-declarations \
-Wlong-long -Winline -Wredundant-decls \
-Wcast-qual -Wcast-align -D__STRICT_ANSI__
```

- Активировать исключения underflow для чисел с плавающей точкой:
```c
// В начале файла:
#include <fenv.h>
// В начале функции main:
fenableexcept(FE_DIVBYZERO | FE_INVALID
  | FE_OVERFLOW | FE_UNDERFLOW);
```


# Работа в системе
Для редактирования исходного кода в графическом режиме можно использовать:
- текстовые редакторы Kate или gedit
- интерактивные среды разработки (Qt Creator, Visual Studio Code)

[Visual Studio Code](https://code.visualstudio.com/download) бесплатна и доступна как для Windows, так и для Mac, Linux.

В терминале:
- vim (нужно прочитать хотя бы [какое-нибудь](https://ru.wikibooks.org/wiki/Vim) [руководство](http://rus-linux.net/MyLDP/BOOKS/Vim/prosto-o-vim.pdf))
- nano (наиболее простой; команды: Ctrl+X — выход, Ctrl+O — сохранение,  Ctrl+W — поиск).


# Использование терминала и командной строки
В разных системах программа для работы с терминалом может называться по-разному.

Запуск программы из текущего каталога:

`./task-19 test-1.in`

Переход между каталогами:

`cd ~/task-19`

Специальные символы:
- `~` — домашний каталог (Shift + клавиша слева от 1)
- `..` — переход на один уровень вверх

Вывод содержимого каталога: `ls`

[Шпаргалка по командам ОС и редактору vim](http://serg.tk/static/docs/1/memosheet.pdf)

# Сборка программы
Сборка программы из нескольких файлов:

`gcc -o task-19 main.c task-19.c`

в несколько этапов:

`gcc -c -o main.o main.c`

`gcc -o task-19 main.o task-19.o`

Аргументы командной строки для компилятора:

- -O0, ..., **-O3**, -Os — уровни оптимизации; сдавать программы, скомпилированные с ключом -O3;
- **-g** — запись отладочной информации (для отладки с использованием gdb), при разработке используйте этот ключ;
- -lm — подключение библиотеки math (для компоновки, последняя команда, если выводятся ошибки о ненайденных символах _sqrt, _fmax, ...)

# Работа с файлами
```c
#include <stdio.h>
```

```c
FILE *f;
f = fopen(fileName, mode); // открыть файл
```
  - `"r"` — чтение
  - `"w"` — запись (если файл уже существует, он будет перезаписан, т.е. его содержмое будет удалено)
  - `"a"` — добавление в конец файла
При ошибке `f == 0`.

```
fclose(f); // закрыть файл
```
при ошибке возвращает `EOF`

# Ввод/вывод
Вывод:
```c
printf("x = %e", x); // на экран
fprintf(f, "x = %e", x); // в файл `f`
```

Чтение: `fscanf(f, " %lf ", &x);`
возвращает количество успешно считанных аргументов,
EOF при ошибке перед первым аргументом.

Спецификаторы форматирования:

- `%c`  — `char`
- `%s` — `char*`
- `%d` — `int, long, ...`
- `%f` — вывод `double`
- `%lf` — ввод `double`
- `%e` — вывод `double`, экспоненциальная запись, лучше не использовать для `scanf`


# Операции с числами с плавающей точкой
```c
#include <math.h>
```

Сравнение: `a == b` — для чисел с плавающей точкой использовать нельзя. Вместо этого:
```
// в начале файла:
#define EPS 1e-16
// в программе: | a - b | < ε
fabs(a - b) < EPS
```

- max(a, b) ⟼ `fmax(a, b)`; min(a, b) ⟼ `fmin(a, b)` (-std=c99)
- $e^x$ ⟼ `exp(x)`; ln x ⟼ `log(x)`; $x^y$ ⟼ `pow(x, y)`
- `sin, cos, tan, asin, acos, atan, sinh, ...`

- $\sqrt{x}$ ⟼ `sqrt(x)`; $\sqrt{x^2+y^2}$ ⟼ `hypot(x, y)`
- $⌈x⌉$ ⟼ `ceil(x)`; $⌊x⌋$ ⟼ `floor(x)`
- $ x · sgn^*(y)$ ⟼ `copysign(x, y)` ($sgn^*(0) ≡ 1$)
- $x · y + z ⟼$ `fma(x, y ,z)` (округляется только результат)
- $ y = [x], z = \{ x \}  ⟼$ `z = modf(x, &y)`

http://en.cppreference.com/w/c/numeric/math

# Система контроля версий Git

Для сдачи заданий будет использоваться система контроля версий Git, а именно - система проверки заданий GitHub Classroom.

В автоматическом режиме производится проверка отсутствия ошибок при сборке, соответствия стилю, другие "быстрые" тесты. После того, как программа пройдёт все автоматические тесты, будет проводиться ручная проверка задачи.

Для работы с этой системой необходимо зарегистрироваться в GitHub.

Тестовое задание: https://classroom.github.com/a/ob_eI_pD

В тестовом задании необходимо вывести на экран фразу `Hello world, it's ` и далее ваше имя и фамилию.

Созданный репозиторий необходимо склонировать к себе на компьютер командой `git clone <ссылка для клонирования>`.

# Система контроля версий Git

После внесения изменений необходимо их отправить в репозиторий.

Проверка изменённых файлов:

`git status`

Добавление изменённых файлов:

`git add file1 file2 ...`

Коммит:

`git -m "сообщение для коммита"`

Отправка изменений в репозиторий:

`git push`

# Заключение

После успешного выполнения задания будет назначена первая зачётная задача.
